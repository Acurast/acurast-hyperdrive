---
title: Getting Started
slug: /get-started
---

The example below explains how a smart contract in an EVM chain with [EIP-1186](https://eips.ethereum.org/EIPS/eip-1186) can communicate with Tezos contracts.

## Contract Implementation and Deployment

### EVM

First, we implement and deploy the EVM contract, which will be a simple counter.

The contract will have two methods, one for incrementing and another for decrementing the counter. In this example, the contract will be callable by anyone, but you could add an [ACL](https://en.wikipedia.org/wiki/Access-control_list) to restrict the accounts allowed to call it.

[Deploy with Remix](https://remix.ethereum.org/#gist=4954f2d73a8c6f3ed186568096fcdf94) (Use Goerli)

```solidity title="client.sol"
pragma solidity ^0.8.17;

library Action {
    string constant INCREMENT = "INCREMENT";
    string constant DECREMENT = "DECREMENT";
}

contract IBCF_Client {
    // The action counter is used in the Tezos blockchain for ordering
    // the actions sequentially and as replay attack prevention.
    uint action_counter;
    // We will generate proofs of the entries contained in this mapping.
    // - These proofs are then used to validate that a given action occurred in this contract.
    mapping(uint => string) action_registry;

    /**
     * Modifier to increase the action counter.
     * Every function using this modifier will increase the action counter when called.
     */
    modifier increase_counter() {
        action_counter += 1;
        _;
    }

    /**
     * @dev Create a increment action.
     */
    function increment() public increase_counter {
        // Update registry (The registry is used for proof generation)
        action_registry[action_counter] = Action.INCREMENT;
    }

    /**
     * @dev Create a decrement action.
     */
    function decrement() public increase_counter {
        // Update registry (The registry is used for proof generation)
        action_registry[action_counter] = Action.DECREMENT;
    }
}
```

### Tezos


[Deploy with SmartPy IDE](/) (Use Ghostnet)

```python title="client.py"
import smartpy as sp

import contracts.tezos.utils.rlp as RLP

class Constant:
    EVM_ACTION_REGISTRY_INDEX = sp.bytes(
        "0x0000000000000000000000000000000000000000000000000000000000000001"
    )

class Error:
    INVALID_VIEW = "INVALID_VIEW"

class Type:
    Validate_storage_proof_argument = sp.TRecord(
        account=sp.TBytes,
        block_number=sp.TNat,
        account_proof_rlp=sp.TBytes,
        storage_slot=sp.TBytes,
        storage_proof_rlp=sp.TBytes,
    ).right_comb()
    ActionArgument = sp.TRecord(
        block_number=sp.TNat,
        account_proof_rlp=sp.TBytes,
        action_proof_rlp=sp.TBytes,
    ).right_comb()

class IBCF_Client(sp.Contract):
    def __init__(self):
        self.init_type(
            sp.TRecord(
                ibcf = sp.TRecord(
                    action_counter=sp.TNat,
                    proof_validator=sp.TAddress,
                    evm_address=sp.TBytes,
                ),
                performed_actions = sp.TList(sp.TString)
            )
        )

    @sp.entry_point(parameter_type=Type.ActionArgument)
    def perform(self, param):
        write_uint_slot_lambda = sp.compute(sp.build_lambda(RLP.EvmStorage.write_uint_slot))
        decode_string_lambda = sp.compute(sp.build_lambda(RLP.EvmStorage.read_string_slot))

        # New action, increase action counter
        self.data.ibcf.action_counter += 1

        # Compute the storage slot for the proof
        action_counter_evm_storage_slot = write_uint_slot_lambda(self.data.ibcf.action_counter)
        action_slot = sp.compute(sp.keccak(action_counter_evm_storage_slot + Constant.EVM_ACTION_REGISTRY_INDEX))

        # Validate proof and extract storage value (The action to be performed)
        rlp_action = sp.view(
            "validate_storage_proof",
            self.data.ibcf.proof_validator,
            sp.set_type_expr(
                sp.record(
                    block_number=param.block_number,
                    account=self.data.ibcf.evm_address,
                    account_proof_rlp=param.account_proof_rlp,
                    storage_slot=action_slot,
                    storage_proof_rlp=param.action_proof_rlp,
                ),
                Type.Validate_storage_proof_argument,
            ),
            t=sp.TBytes,
        ).open_some(Error.INVALID_VIEW)

        # Decode action
        action = decode_string_lambda(rlp_action)

        self.data.performed_actions.push(action)
```

TODO
